<?php
/**
 * Output regular expression alternatives statics or defines
 * for general category codepoints (default "Mn" nonspacing combining marks)
 * from the UCD unicode data file "UnicodeData.txt".
 *
 * See http://www.unicode.org/Public/9.0.0/ucd/UnicodeData.txt
 */

$basename = basename( __FILE__ );
$dirname = dirname( __FILE__ );
$dirdirname = dirname( $dirname );
$subdirname = basename( $dirname );

require $dirname . '/functions.php';

// Arguments.

$opts = getopt( 'p:g:cv:' );
$prefix = isset( $opts['p'] ) ? $opts['p'] : 'static';
$general_cats = isset( $opts['g'] ) ? explode( ',', $opts['g'] ) : array( 'Mn' );
$concat = isset( $opts['c'] );
$version = isset( $opts['v'] ) ? $opts['v'] : '9.0.0';

if ( ! function_exists( '__' ) ) {
	function __( $str, $td ) { return $str; }
}

// Open the unicode file.

$filename = '/tests/UCD-' . $version . '/UnicodeData.txt';
$file = $dirdirname . $filename;
error_log( "$basename: reading file=$file" );

// Callback for Unicode data file parser.
function parse_unicode_data_cb( &$codepoints, $cp, $name, $parts, $in_interval, $first_cp, $last_cp ) {
	global $general_cats;

	$general_cat = $parts[UNFC_UCD_GENERAL_CATEGORY];
	$general_cat_super = strlen( $general_cat ) > 1 ? $general_cat[0] : null;
	if ( $general_cats && ! in_array( $general_cat, $general_cats ) && ( ! $general_cat_super || ! in_array( $general_cat_super, $general_cats ) ) ) {
		return;
	}
	if ( ! isset( $codepoints[ $general_cat ] ) ) {
		$codepoints[ $general_cat ] = array();
	}
	if ( $general_cat_super && ! isset( $codepoints[ $general_cat_super ] ) ) {
		$codepoints[ $general_cat_super ] = array();
	}
	$codepoints[ $general_cat ][] = $cp;
	if ( $general_cat_super ) {
		$codepoints[ $general_cat_super ][] = $cp;
	}
}

// Read the file.

$codepoints = unfc_parse_unicode_data( $file, 'parse_unicode_data_cb' );
if ( false === $codepoints ) {
	/* translators: %s: file name */
	$error = sprintf( __( 'Could not read unicode data file "%s"', 'unfc' ), $file );
	error_log( $error );
	return $error;
}

ksort( $codepoints );

// Output.

$indent = 'static' === $prefix ? "\t\t\t" : '';
$out = array();
$out[] =  $concat ? '' : '<?php';
$out[] = $indent . '// Generated by "' . $basename . '" from "http://www.unicode.org/Public/' . $version . '/ucd/UnicodeData.txt".';

foreach ( $codepoints as $general_cat => $general_cat_cps ) {
	if ( $general_cats && ! in_array( $general_cat, $general_cats ) ) {
		continue;
	}
	sort( $general_cat_cps );

	// Calculate the UTF-8 byte sequence ranges from the unicode codepoints.
	$ranges = unfc_utf8_ranges_from_codepoints( $general_cat_cps );

	// Generate the regular expression alternatives.
	$regex_alts = unfc_utf8_regex_alts( $ranges );

	if ( 'static' === $prefix ) {
		$out[] = $indent . 'static $' . strtolower( $general_cat ) . "_regex_alts = '" . $regex_alts . "'; // " . count( $general_cat_cps ) . " code points.";
	} else {
		$out[] = "define( '{$prefix}" . strtoupper( $general_cat ) . "_REGEX_ALTS', '" . $regex_alts . "' ); // " . count( $general_cat_cps ) . " code points.";
	}
}

$out = implode( "\n", $out ) . "\n";

if ( $concat ) echo stream_get_contents( STDIN );
echo $out;
