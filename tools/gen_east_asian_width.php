<?php
/**
 * Output regular expression alternatives globals, statics or defines (default globals)
 * for wide and full width codepoints
 * from the UCD unicode data file "EastAsianWidth.txt".
 *
 * See http://www.unicode.org/Public/10.0.0/ucd/EastAsianWidth.txt
 */

$basename = basename( __FILE__ );
$dirname = dirname( __FILE__ );
$dirdirname = dirname( $dirname );
$subdirname = basename( $dirname );

require $dirname . '/functions.php';

// Arguments.

$opts = getopt( 'p:cv:u:o:' );
$prefix = isset( $opts['p'] ) ? $opts['p'] : 'global'; // 'global' or 'static' or blank for defines.
$concat = isset( $opts['c'] ); // If set will concatenation output to STDIN, with no '<?php' prefix, otherwise will output '<?php' prefix and no concatenation.
$version = isset( $opts['v'] ) ? $opts['v'] : '10.0.0'; // Unicode version number.
$unicode = isset( $opts['u'] ) ? $opts['u'] : ''; // Blank for UTF-8 regex, 'unicode' for Unicode regex, or 'both' for both.
$output = isset( $opts['o'] ) ? $opts['o'] : 'regex_alts'; // 'regex_alts' for regex alternatives sub-expression, 'regex' for full regex expression, or 'both' for both.

if ( ! function_exists( '__' ) ) {
	function __( $str, $td ) { return $str; }
}

// Open the East Asian width file.

$filename = '/tests/UCD-' . $version . '/EastAsianWidth.txt';
$file = $dirdirname . $filename;
error_log( "$basename: reading file=$file" );

// Read the file.

if ( false === ( $get = file_get_contents( $file ) ) ) {
	/* translators: %s: file name */
	$error = sprintf( __( 'Could not read East Asian width file "%s"', 'unfc-normalize' ), $file );
	error_log( $error );
	return $error;
}

$lines = array_map( 'unfc_get_cb', explode( "\n", $get ) ); // Strip newlines.

// Parse the file, creating array of wide and full width codepoints.

$wides = array();
$in = false;
$line_num = 0;
foreach ( $lines as $line ) {
	$line_num++;
	$line = trim( $line );
	if ( '' === $line ) {
		continue;
	}
	if ( ! preg_match( '/^([0-9A-F]{4,})(\.\.[0-9A-F]{4,})?;(?:F|W)/', $line, $matches ) ) {
		continue;
	}
	if ( isset( $matches[2] ) ) {
		$begin = hexdec( $matches[1] );
		$end = hexdec( substr( $matches[2], 2 ) );
		for ( $i = $begin; $i <= $end; $i++ ) {
			$wides[] = $i;
		}
	} else {
		$wides[] = hexdec( $matches[1] );
	}
}

sort( $wides );

// Output.

$indent = 'static' === $prefix ? "\t" : '';
$out = array();
$out[] =  $concat ? '' : '<?php';
$out[] = $indent . '// Generated by "' . $basename . '" from "http://www.unicode.org/Public/' . $version . '/ucd/EastAsianWidth.txt".';

if ( 'static' === $prefix || 'global' === $prefix ) {
	$preface = $indent . ( 'static' === $prefix ? 'static ' : '' ) . '$eaw_regex';
} else {
	$preface = "define( 'EAW_REGEX";
}

$num_cps_comment = " // " . count( $wides ) . " code points.";
$both_num_cps_comment = 'both' === $output ? '' : $num_cps_comment;

if ( '' === $unicode || 'both' === $unicode ) {
	// Calculate the UTF-8 byte sequence ranges from the unicode codepoints.
	$ranges = unfc_utf8_ranges_from_codepoints( $wides );

	// Generate the regular expression alternatives.
	$regex_alts = unfc_utf8_regex_alts( $ranges );

	if ( 'static' === $prefix || 'global' === $prefix ) {
		if ( 'regex_alts' === $output || 'both' === $output ) {
			$out[] = $preface . "_alts = '" . $regex_alts . "';" . $num_cps_comment;
		}
		if ( 'regex' === $output || 'both' === $output ) {
			$out[] = $preface . " = '/" . ( 'both' === $output ? "' . \$eaw_regex_alts . '" : $regex_alts ) . "/';" . $both_num_cps_comment;
		}
	} else {
		if ( 'regex_alts' === $output || 'both' === $output ) {
			$out[] = $preface . "_ALTS', '" . $regex_alts . "' );" . $num_cps_comment;
		}
		if ( 'regex' === $output || 'both' === $output ) {
			$out[] = $preface . "', '/" . ( 'both' === $output ? "' . EAW_REGEX_ALTS . '" : $regex_alts ) . "/' );" . $both_num_cps_comment;
		}
	}
}

if ( 'unicode' === $unicode || 'both' === $unicode ) {
	// Generate the regular expression alternatives.
	$regex_alts = unfc_unicode_regex_chars_from_codepoints( $wides );

	if ( 'static' === $prefix || 'global' === $prefix ) {
		if ( 'regex_alts' === $output || 'both' === $output ) {
			$out[] = "{$preface}_alts_u = '{$regex_alts}';{$num_cps_comment}";
		}
		if ( 'regex' === $output || 'both' === $output ) {
			$out[] = "{$preface}_u = '/[" . ( 'both' === $output ? "' . \$eaw_regex_alts_u . '" : $regex_alts ) . "]/u';{$both_num_cps_comment}";
		}
	} else {
		if ( 'regex_alts' === $output || 'both' === $output ) {
			$out[] = "{$preface}_ALTS_U', '{$regex_alts}' );{$num_cps_comment}";
		}
		if ( 'regex' === $output || 'both' === $output ) {
			$out[] = "{$preface}_U', '/[" . ( 'both' === $output ? "' . EAW_REGEX_ALTS_U . '" : $regex_alts ) . "]/u' );{$both_num_cps_comment}";
		}
	}
}

$out = implode( "\n", $out ) . "\n";

if ( $concat ) echo stream_get_contents( STDIN );
echo $out;
