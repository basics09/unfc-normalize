<?php
/**
 * Output regular expression alternatives statics or defines
 * for scripts codepoints (default "Latin")
 * from the UCD unicode data file "Scripts.txt".
 *
 * See http://www.unicode.org/Public/9.0.0/ucd/Scripts.txt
 */

$basename = basename( __FILE__ );
$dirname = dirname( __FILE__ );
$dirdirname = dirname( $dirname );
$subdirname = basename( $dirname );

require $dirname . '/functions.php';

// Arguments.

$opts = getopt( 'p:s:cv:g:u' );
$prefix = isset( $opts['p'] ) ? $opts['p'] : 'static';
$scripts = isset( $opts['s'] ) ? explode( ',', $opts['s'] ) : array( 'Latin' );
$concat = isset( $opts['c'] );
$version = isset( $opts['v'] ) ? $opts['v'] : '9.0.0';
$general_cat = isset( $opts['g'] ) ? $opts['g'] : '';
$union = isset( $opts['u'] );

if ( ! function_exists( '__' ) ) {
	function __( $str, $td ) { return $str; }
}

// Open the unicode file.

$filename = '/tests/UCD-' . $version . '/Scripts.txt';
$file = $dirdirname . $filename;
error_log( "$basename: reading file=$file" );

// Callback for Scripts file parser.
function parse_scripts_cb( &$codepoints, $cp, $script, $parts, $in_interval, $first_cp, $last_cp ) {
	global $scripts, $general_cat;

	if ( $scripts && ! in_array( $script, $scripts ) ) {
		return;
	}
	if ( $general_cat && ! empty( $parts[2] ) && 0 !== strpos( $parts[2], $general_cat ) ) {
		return;
	}
	if ( ! isset( $codepoints[ $script ] ) ) {
		$codepoints[ $script ] = array();
	}
	$codepoints[ $script ][] = $cp;
}

// Read the file.

$codepoints = unfc_parse_scripts( $file, 'parse_scripts_cb' );
if ( false === $codepoints ) {
	/* translators: %s: file name */
	$error = sprintf( __( 'Could not read scripts file "%s"', 'unfc' ), $file );
	error_log( $error );
	return $error;
}

if ( ! $union ) {
	ksort( $codepoints );
}

// Output.

$indent = 'static' === $prefix ? "\t\t\t" : '';
$out = array();
$out[] =  $concat ? '' : '<?php';
$out[] = $indent . '// Generated by "' . $basename . '" from "http://www.unicode.org/Public/' . $version . '/ucd/Scripts.txt".';

$cat_prefix = $general_cat ? ( ( 'static' === $prefix ? strtolower( $general_cat ) : strtoupper( $general_cat ) ) . '_' ) : '';
if ( $union ) {
	$union_codepoints = array();
	foreach ( $codepoints as $script => $script_codepoints ) {
		$union_codepoints = array_merge( $union_codepoints, $script_codepoints );
	}
	$ranges = unfc_utf8_ranges_from_codepoints( $union_codepoints );
	$regex_alts = unfc_utf8_regex_alts( $ranges );
	if ( 'static' === $prefix ) {
		$out[] = $indent . "static \${$cat_prefix}" . strtolower( implode( '_', array_keys( $codepoints ) ) ) . "_regex_alts = '" . $regex_alts . "'; // " . count( $union_codepoints ) . " code points.";
	} else {
		$out[] = "define( '{$prefix}{$cat_prefix}" . strtoupper( implode( '_', array_keys( $codepoints ) ) ) . "_REGEX_ALTS', '" . $regex_alts . "' ); // " . count( $union_codepoints ) . " code points.";
	}
} else {
	foreach ( $codepoints as $script => $script_codepoints ) {
		sort( $script_codepoints );
		$ranges = unfc_utf8_ranges_from_codepoints( $script_codepoints );
		$regex_alts = unfc_utf8_regex_alts( $ranges );
		if ( 'static' === $prefix ) {
			$out[] = $indent . "static \${$cat_prefix}" . strtolower( $script ) . "_regex_alts = '" . $regex_alts . "'; // " . count( $script_codepoints ) . " code points.";
		} else {
			$out[] = "define( '{$prefix}{$cat_prefix}" . strtoupper( $script ) . "_REGEX_ALTS', '" . $regex_alts . "' ); // " . count( $script_codepoints ) . " code points.";
		}
	}
}

$out = implode( "\n", $out ) . "\n";

if ( $concat ) echo stream_get_contents( STDIN );
echo $out;
